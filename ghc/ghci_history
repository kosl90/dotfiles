:t foldr
[show  i | i <- [1..9]]
:k exp
exp 1
:info exp
:t exp
:m +Data.Map 
:t Data.List.unionBy 
foldr Data.List.unionBy  "" ["test", "a"]
foldr Data.List.union "" ["test", "a"]
foldr Data.List.union ["test", "a"]
Data.List.union "t" "a"
:t Data.List.union 
:t Data.List.union "" "test"
:t Data.List.union "" ["test", "a"]
:t Data.List.union 
:t Data.List.mapAccumR
:t Data.List.union
:m +Data.List 
table 
:r
:e
:r
:e
table 
:r
:e
result 
:r
:e
putStr aux 
print aux 
aux 
let aux = foldl (++) "" table 
:t aux 
let aux = foldl (++)
:t table 
:t aux
aux !! 0
aux
let aux = foldl (++) table 
foldl (++) table 
putStr table 
print table 
table 
:r
:e
:r
:e
:e
:r
:e
:e
:e
:r
:e
table 
:r
:e
:r
:e
:r
:e
[(x,y) | x<-[1..9],y<-[1..x]]
[(x,y) | x<-[1..9],y<-[1..9]]
[(x,y) | x<-[1..9],y<-[1..x]]
let a = [(x,y) | x<-[1..9],y[1..x]]
[(x,y) | x<-[1..9],y[1..x]]
:t unwords 
:t until 
:t words 
:t lines
:e
table 
:r
:e
:r
:e
:r
:e
aux
:r
:e
aux'
:r
:e
aux 
:r
:e
aux 
:r
:e
:r
:e
[1..1]
:e
aux 
:e
aux 
:r
